---
title: "GEO879 - Mobility Issues Project"
author: "Cyril Geistlich, Annika Kunz, Fabienne Koenig"
date: "2023-10-11"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Load Libraries

```{r setup, include=FALSE, warning = F}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(warning = FALSE, message = FALSE) 

# Install/load packages
## Default repository
local({r <- getOption("repos")
       r["CRAN"] <- "http://cran.r-project.org" 
       options(repos = r)
})

check_pkg <- function(x)
  {
    if (!require(x, character.only = TRUE))
    {
      install.packages(x, dep = TRUE)
        if(!require(x, character.only = TRUE)) stop("Package not found")
    }
}

check_pkg("sf")
check_pkg("httr")
check_pkg("ggplot2")
check_pkg("tidyverse")
check_pkg("leaflet")
check_pkg("dplyr")
check_pkg("XML")
check_pkg("mapview")
check_pkg("lubridate")
check_pkg("dplyr")
check_pkg("readr") 
check_pkg("tmap")
check_pkg("spatstat") 
check_pkg("dbscan")
check_pkg("ellipse")
check_pkg("phonTools")


```

```{r Projections}
# Projection strings for the Swiss LV03 & LV95 CRS and WGS84 CRS, respectively
crs_lv03  <- 21781
crs_lv95  <- 2056
crs_wgs84 <- 4326
```


## Read Data

```{r}
# I use .gpkg, since it is delivererd in Lv95 and no further tranformation is needed. 
accidents <- st_read( "data/RoadTrafficAccidentLocations.gpkg")
zh_boundary <- st_read( "data/Zurich_city_boundary.gpkg")
zh_districts <- st_read( "data/Zurich_city_districts.gpkg")
```
All layers are in CH1903+ / LV95. Therefore no further transformations are needed. 

## Data Preview

```{r Tables}
# a)
accidents |> ggplot() +
  geom_bar(aes(AccidentSeverityCategory)) +
  xlab("Accident Severity Category") +
  ggtitle("Number of Accidents by Severity")

# b)
accidents |> ggplot() +
  geom_bar(aes(AccidentType)) +
  xlab("Accident Category") +
  ggtitle("Number of Accidents by Category")

# c)

p <- accidents |>
  filter(AccidentInvolvingPedestrian == T &
         AccidentInvolvingBicycle == F &
         AccidentInvolvingMotorcycle == F)

b <- accidents |>
  filter(AccidentInvolvingPedestrian == F &
         AccidentInvolvingBicycle == T &
         AccidentInvolvingMotorcycle == F)

m <- accidents |>
  filter(AccidentInvolvingPedestrian == F &
         AccidentInvolvingBicycle == F &
         AccidentInvolvingMotorcycle == T)

pb <- accidents |>
  filter(AccidentInvolvingPedestrian == T &
         AccidentInvolvingBicycle == T &
         AccidentInvolvingMotorcycle == F)

pm <- accidents |>
  filter(AccidentInvolvingPedestrian == T &
         AccidentInvolvingBicycle == F &
         AccidentInvolvingMotorcycle == T)

bm <- accidents |>
  filter(AccidentInvolvingPedestrian == F &
         AccidentInvolvingBicycle == T &
         AccidentInvolvingMotorcycle == T)

pbm <- accidents |>
  filter(AccidentInvolvingPedestrian == T &
         AccidentInvolvingBicycle == T &
         AccidentInvolvingMotorcycle == T)


counts_table <- data.frame(
  Type = c("Pedestrian","Bicycle","Motorcycle","Pedestrian & Bicycle", "Pedestrian & Motorcycle", "Bicycle & Motorcycle", "Pedestrian & Bicycle & Motorcycle"),
  Count = c(nrow(p),nrow(b),nrow(m),nrow(pb), nrow(pm), nrow(bm), nrow(pbm))
)

print(counts_table)


```

## Temporal Evolution

```{r temporal evolution plot}

temporal_plot <- accidents |>
  group_by(AccidentYear) |>
  summarise(Count = n()) |>
  ggplot() +
  geom_line(aes(x = AccidentYear, y = Count))

temporal_plot_b <- b |>
  group_by(AccidentYear) |>
  summarise(Count = n()) |>
  ggplot() +
  geom_line(aes(x = AccidentYear, y = Count))

combined_plot <- ggplot() +
  geom_line(data = temporal_plot$data, aes(x = AccidentYear, y = Count, linetype = "All Accidents"), size = 1, color = "black") +
  geom_line(data = temporal_plot_b$data, aes(x = AccidentYear, y = Count, linetype = "Bicycle Accidents"), size = 1, color = "red") +
  geom_text(data = temporal_plot$data, aes(x = AccidentYear, y = Count, label = Count), vjust = -1, hjust = -0.5, size = 3, color = "black") +
  geom_text(data = temporal_plot_b$data, aes(x = AccidentYear, y = Count, label = Count), vjust = -1, hjust = -0.5, size = 3, color = "red") +
  xlab("Year") +
  ylab("Number of Accidents") +
  ggtitle("Accidents Over the Years") +
  scale_x_continuous(breaks = unique(accidents$AccidentYear)) +
  scale_linetype_manual(values = c("All Accidents" = "solid", "Bicycle Accidents" = "solid")) +
  guides(linetype = guide_legend(override.aes = list(color = c("black", "red"))) )  +
  scale_color_manual(values = c("All Accidents" = "black", "Bicycle Accidents" = "red")) +
  labs(linetype = "Transport Mode Type")

print(combined_plot)

```

## Accident Severity

```{r Tmap Accident Severity}

tmap_mode("view")

basemap_imagery <-tm_basemap("Esri.WorldTopoMap") +
  tm_basemap("Esri.WorldImagery") +
  tm_basemap("Esri.WorldStreetMap") +
  tm_basemap("Esri.WorldGrayCanvas")

accident_map <- tm_shape(b) +
  tm_dots(col = "AccidentSeverityCategory_en", palette = "Set1", size = 0.02) + 
  tm_layout(
    title = "Accident Severity Map of Zurich", 
    title.position = c('left', 'top'), 
    legend.frame = T
  ) +
  tm_shape(zh_boundary) +
  tm_borders() +
  tm_shape(zh_districts) +
  tm_borders() +
  basemap_imagery 

accident_map

```

# Clustering of Accidents

Most accidents occur on or close to intersections. We have accumulations of accidents along larger streets. This might be the case because those streets might be cycled on more frequently and at a higher average velocity. 

```{r dbscan}

sf_data <- b
years <- c(2018, 2019, 2020, 2021)
cluster_maps <- list()

for (year in years) {
  data_year <- sf_data[sf_data$AccidentYear == year, ]
  coordinates_df <- st_coordinates(data_year)

  dbscan_result <- dbscan(coordinates_df, eps = 125)

  # move cluster 0 to own layer
  data_year_cluster0 <- data_year[dbscan_result$cluster == 0, ]
  data_year_cluster0$Cluster <- as.factor(dbscan_result$cluster[dbscan_result$cluster == 0])
  
  data_year <- data_year[dbscan_result$cluster != 0, ]
  data_year$Cluster <- as.factor(dbscan_result$cluster[dbscan_result$cluster != 0])

  cluster_map <- tm_shape(data_year) +
    tm_dots(col = "Cluster", palette = "Set1", size = 0.01) +
    tm_shape(data_year_cluster0) +
    tm_dots(col = "Cluster", size = 0.01) +
    tm_shape(zh_boundary) +
    tm_borders() +
    tm_shape(zh_districts) +
    tm_borders() +
    tm_layout(
      title = paste("DBSCAN Clustering Map - Year", year),
      title.position = c('left', 'top'),
      legend.frame = TRUE
    )

  cluster_maps[[as.character(year)]] <- cluster_map

  assign(paste0("b_", year), data_year)
}

for (year in years) {
  print(cluster_maps[[as.character(year)]])
}

```


Cluster 0 was filtered out, since the data points in the cluster were spread out through the whole city. After removing the other smaller clusters become better visible in the maps. The clusters are along larger roads or at large intersection with a lot of traffic.

```{r SDE, include = F}

# Create a list to store ellipses
ellipses <- data.frame()
clusters <- unique(b_2018$Cluster)
ellipses_list <- list()

# 2018
  # Create and add ellipses for each cluster
  for (cluster in clusters) {
    sde_cluster <- b_2018[b_2018$Cluster == cluster, ]
    coords <- as.matrix(st_coordinates(st_as_sf(sde_cluster)))
  
    # Create standard deviation ellipse
    plot.new()
    ellipse_data <- as.data.frame(sdellipse(coords))
    
    # Create the polygon object
    polygon <- ellipse_data |>
    st_as_sf(coords = c("V1", "V2"), crs = 2056) |>
    summarise((geometry = st_combine(geometry))) |>
    st_cast("POLYGON")
  
    polygon$Cluster <- cluster
  
    # Add the polygon to the list
    ellipses_list[[cluster]] <- polygon
    ellipses_2018 <- do.call(rbind, ellipses_list)
}

# 2021
clusters <- unique(b_2021$Cluster)
  # Create and add ellipses for each cluster
  for (cluster in clusters) {
    sde_cluster <- b_2021[b_2021$Cluster == cluster, ]
    coords <- as.matrix(st_coordinates(st_as_sf(sde_cluster)))
  
    # Create standard deviation ellipse
    plot.new()
    ellipse_data <- as.data.frame(sdellipse(coords))
  
    # Create the polygon object
    polygon <- ellipse_data |>
    st_as_sf(coords = c("V1", "V2"), crs = 2056) |>
    summarise((geometry = st_combine(geometry))) |>
    st_cast("POLYGON")
  
    polygon$Cluster <- cluster
  
    # Add the polygon to the list
    ellipses_list[[cluster]] <- polygon
    ellipses_2021 <- do.call(rbind, ellipses_list)
}

```


```{r ellipse map}
ellipse_map_18 <- tm_shape(zh_boundary) +
    tm_borders() +
    tm_shape(zh_districts) +
    tm_borders() +
    tm_shape(ellipses_2018) +
    tm_polygons(alpha = 0.5, palette = "Set1") +
    tm_shape(b_2018) +
    tm_dots(col = "Cluster", palette = "Set1", size = 0.01) +
    tmap_options(check.and.fix = TRUE) +
    tm_layout(
      title = paste("DBSCAN Clustering Map - Year", 2018),
      title.position = c('left', 'top'),
      legend.frame = TRUE
  )

ellipse_map_21 <- tm_shape(zh_boundary) +
    tm_borders() +
    tm_shape(zh_districts) +
    tm_borders() +
    tm_shape(ellipses_2021) +
    tm_polygons(alpha = 0.5, palette = "Set1") +
    tm_shape(b_2021) +
    tm_dots(col = "Cluster", palette = "Set1", size = 0.01) +
    tmap_options(check.and.fix = TRUE) +
    tm_layout(
      title = paste("DBSCAN Clustering Map - Year", 2021),
      title.position = c('left', 'top'),
      legend.frame = TRUE
  )
ellipse_map_18
ellipse_map_21
```


## Track Data


```{r load GPX data}
gpx_parsed_A <- htmlTreeParse(file = "data/Geo879_route_Annika.gpx", useInternalNodes = TRUE)
gpx_parsed_F <- htmlTreeParse(file = "data/Geo879_route_Fabienne.gpx", useInternalNodes = TRUE)
gpx_parsed_C <- htmlTreeParse(file = "data/Geo879_route_Cyril.gpx", useInternalNodes = TRUE)

```

Extract and store them in a more readable structure:
```{r extract info to dataframe}
coords <- xpathSApply(doc = gpx_parsed_A, path = "//trkpt", fun = xmlAttrs)
elevation <- xpathSApply(doc = gpx_parsed_A, path = "//trkpt/ele", fun = xmlValue)
ts_chr <- xpathSApply(gpx_parsed_A, path = "//trkpt/time", xmlValue)

track <- data.frame(
  ts_POSIXct = ymd_hms(ts_chr, tz = "UTC"),
  lat = as.numeric(coords["lat", ]),
  lon = as.numeric(coords["lon", ]),
  elevation = as.numeric(elevation)
)

# Add index to df
track$index <- 1:nrow(track)
```

```{r convert to sf object and build trajectory}
track_sf <- st_as_sf(x = track, coords = c("lon","lat"), crs = 4326) %>% arrange(index)
mapview(track_sf)

# Creating trajectory by combining the coordinate points into multipoint feature
traj <- st_union(track_sf$geometry)
traj_sf <- st_sf(geometry = traj) %>% st_cast("LINESTRING")
# mapview(traj_sf) # NOT WORKING PROPERLY > ORDER IS NOT CORRECT
```

## Read Empatica Data

# EDA - Electrodermal Activity (Unit: microsiemens)

```{r}
EDA_A <- read_csv("data/E4_data_Annika/EDA.csv")
temp_A <- read_csv("data/E4_data_Annika/tags.csv")
```


